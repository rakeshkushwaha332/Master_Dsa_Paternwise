# üöÄ Complete DSA Pattern-Wise Question Bank

A comprehensive collection of Data Structures and Algorithms questions organized by patterns and difficulty levels.

---

## üìã Table of Contents

- [Arrays](#-arrays)
- [Strings](#-strings)
- [Searching](#-searching--sorting)
- [Linked Lists](#-linked-lists)
- [Stacks & Queues](#-stacks--queues)
- [Recursion & Backtracking](#-recursion--backtracking)
- [Trees](#-trees)
- [Heaps](#-heaps)
- [Graphs](#-graphs)
- [Greedy Algorithms](#-greedy-algorithms)

---

## üî¢ ARRAYS

### 1Ô∏è‚É£ Basic Traversal / Brute Force
**Foundation Pattern** ‚Ä¢ *15 Questions*

- [Easy] Find largest element in array
- Find second largest element
- Check if array is sorted
- Find missing number (0‚Ä¶n)
- Find duplicate element
- Leaders in an array
- Equilibrium index
- Majority element (> n/2)
- Majority element (> n/3)
- Rearrange array alternately (max‚Äìmin)
- Count inversions
- Maximum difference j ‚àí i such that arr[j] > arr[i]
- Minimum jumps to reach end
- Trapping rain water
- Maximum product of triplet

### 2Ô∏è‚É£ Two Pointers
**Optimization Pattern** ‚Ä¢ *15 Questions*

- [Easy] Reverse an array
- Two sum (sorted array)
- Remove duplicates from sorted array
- Container with most water
- Pair with given difference
- 3Sum
- 4Sum
- Sort 0s, 1s, 2s (DNF)
- Trapping rain water
- Partition array around pivot
- Count pairs with given sum
- Minimize max difference between pairs
- Remove element in-place
- Find closest pair from two arrays
- Valid triangle number

### 3Ô∏è‚É£ Sliding Window
**Very High Priority** ‚Ä¢ *15 Questions*

- [Easy] Maximum sum subarray of size K
- First negative number in every window
- Count subarrays of size K with sum X
- Longest subarray with sum ‚â§ K
- Maximum of all subarrays of size K
- Longest subarray with at most K distinct elements
- Minimum size subarray sum ‚â• S
- Subarray with product < K
- Sliding window maximum (Deque)
- Longest alternating subarray
- Count nice subarrays
- Binary subarrays with sum
- Fruits into baskets
- Longest subarray with equal 0s & 1s
- Shortest subarray with sum at least K (Hard)

### 4Ô∏è‚É£ Prefix Sum / Cumulative Sum
**Optimization Core** ‚Ä¢ *15 Questions*

- [Easy] Range sum query
- Subarray sum equals K
- Count subarrays with sum = 0
- Longest subarray with sum = K
- Maximum subarray sum (Kadane)
- Find pivot index
- Continuous subarray divisible by K
- Count subarrays with equal 0s and 1s
- Maximum sum circular subarray
- Subarray sum divisible by K
- Maximum absolute subarray sum
- Minimum operations to reduce X to zero
- Make sum divisible by P
- Count subarrays with odd sum
- 2D prefix sum range query (Hard)

### 5Ô∏è‚É£ Hashing in Arrays
**Must-Master** ‚Ä¢ *15 Questions*

- [Easy] Check duplicates
- Two sum (unsorted)
- Longest consecutive sequence
- Majority element (> n/3)
- Count pairs with given sum
- Subarray sum equals K
- Count distinct elements in every window
- Find all duplicates
- Smallest subarray with all distinct elements
- Longest subarray with equal 0s & 1s
- Subarrays with XOR = K
- Count pairs divisible by K
- Longest subarray with sum divisible by K
- Find repeating & missing number
- Maximum size subarray sum equals K (Hard)

### 6Ô∏è‚É£ Binary Search (Including Answer Space)
**Top Interview Topic** ‚Ä¢ *15 Questions*

- [Easy] Binary search
- First & last occurrence
- Search in rotated sorted array
- Find minimum in rotated array
- Peak element
- Square root using binary search
- Allocate minimum pages
- Aggressive cows
- Koko eating bananas
- Capacity to ship packages
- Median of two sorted arrays
- Find Kth smallest element
- Minimum days to make bouquets
- Split array largest sum
- Search in infinite sorted array (Hard)

### 7Ô∏è‚É£ Kadane / DP on Arrays
**DP Thinking** ‚Ä¢ *15 Questions*

- [Easy] Maximum subarray sum
- Maximum sum circular subarray
- Maximum product subarray
- Longest increasing subarray
- Stock buy & sell (1 transaction)
- Stock buy & sell (multiple)
- Stock buy & sell (cooldown)
- Stock buy & sell (k transactions)
- Maximum sum increasing subsequence
- Partition array for maximum sum
- Delete and earn
- House robber
- Jump game II
- Maximum alternating subsequence sum
- Burst balloons (Hard)

### 8Ô∏è‚É£ Sorting-Based Pattern
**Sort ‚Üí Simplify** ‚Ä¢ *15 Questions*

- [Easy] Sort 0s and 1s
- Merge two sorted arrays
- Find pair with sum closest to X
- Chocolate distribution problem
- Minimum number of platforms
- Merge intervals
- Count inversions
- Minimum swaps to sort array
- Maximum meetings in one room
- Kth smallest element
- Find duplicates using sorting
- Maximum product of two elements
- Minimum difference pair
- Sort by frequency
- Russian Doll Envelopes (Hard)

### 9Ô∏è‚É£ Partition / Rearrangement
**In-Place Mastery** ‚Ä¢ *15 Questions*

- [Easy] Move zeros to end
- Segregate even and odd
- Rearrange positives & negatives alternately
- Partition array around range
- Dutch National Flag
- Minimum swaps to group elements
- Rearrange array such that arr[i] = i
- Sort array by parity II
- Wiggle sort
- Arrange numbers to form largest number
- Stable partition
- Minimum swaps to make array beautiful
- Sort array by sign
- Three-way partitioning
- Partition labels (Hard)

### üîü Cyclic / Rotation Pattern
**Tricky Logic** ‚Ä¢ *15 Questions*

- [Easy] Rotate array by K
- Check if array is rotated & sorted
- Find pivot element
- Search in rotated array
- Maximum sum i √ó arr[i]
- Rotation count
- Minimum element in rotated array
- Circular subarray sum
- Juggling algorithm rotation
- Best time to rotate for max score
- Find element in circular sorted array
- Rotation with queries
- Cyclic sort
- Find missing numbers (cyclic sort)
- Find duplicate number (Hard)

### 1Ô∏è‚É£1Ô∏è‚É£ Matrix / 2D Arrays
**Array Extension** ‚Ä¢ *15 Questions*

- [Easy] Matrix traversal
- Spiral matrix
- Rotate matrix by 90¬∞
- Search in 2D matrix
- Set matrix zeroes
- Diagonal traversal
- Flood fill
- Word search
- Maximum sum submatrix
- Count square submatrices with all 1s
- Largest rectangle in histogram
- Largest rectangle in binary matrix
- Shortest path in binary matrix
- Matrix chain multiplication
- Sudoku solver (Hard)

---

## üî§ STRINGS

### 1Ô∏è‚É£ Basic Traversal / Brute Force
**Foundation of Strings** ‚Ä¢ *15 Questions*

- [Easy] Reverse a string
- Check if a string is palindrome
- Count vowels, consonants, digits
- Find duplicate characters
- Remove duplicate characters
- Check if two strings are anagrams
- Find first non-repeating character
- Count words in a string
- Find longest word in a sentence
- Check if string is rotation of another
- Maximum occurring character
- Replace spaces with %20
- Print all substrings
- Check balanced parentheses (brute)
- Count all palindromic substrings

### 2Ô∏è‚É£ Two Pointers
**Left‚ÄìRight Scanning** ‚Ä¢ *15 Questions*

- [Easy] Check palindrome
- Reverse words in a string
- Remove vowels from string
- Remove adjacent duplicates
- Valid palindrome II
- Longest palindromic substring
- String compression
- Compare version numbers
- Minimum deletions to make palindrome
- Merge strings alternately
- Backspace string compare
- Sort characters by frequency
- Make string alternating
- Shortest distance to a character
- Palindrome partitioning (Hard)

### 3Ô∏è‚É£ Sliding Window
**MOST IMPORTANT for Strings** ‚Ä¢ *15 Questions*

- [Easy] Longest substring without repeating characters
- Longest substring with at most K distinct characters
- Longest substring with exactly K distinct characters
- Smallest window containing all characters of another string
- Permutation in string
- Find all anagrams in a string
- Longest repeating character replacement
- Count substrings with at most K distinct characters
- Longest substring with same characters after K changes
- Substring with concatenation of all words
- Longest nice substring
- Number of substrings containing all 3 characters
- Binary string with sum K
- Longest substring with even vowels
- Minimum window substring (Hard)

### 4Ô∏è‚É£ Hashing / Frequency Map
**Optimization Core** ‚Ä¢ *15 Questions*

- [Easy] Check if two strings are anagrams
- First unique character
- Count frequency of characters
- Group anagrams
- Longest palindrome that can be built
- Isomorphic strings
- Check if permutation exists
- Find duplicate words in sentence
- Sort characters by frequency
- Maximum number of vowels in substring of size K
- Count distinct substrings
- Longest substring with equal 0s and 1s
- Smallest substring with all distinct characters
- Count palindromic subsequences
- Longest substring with same frequency (Hard)

### 5Ô∏è‚É£ Prefix / Suffix Patterns
**Preprocessing Logic** ‚Ä¢ *15 Questions*

- [Easy] Check prefix of string
- Longest common prefix
- Count prefix matches
- Prefix frequency array
- Z-algorithm basics
- Prefix function (KMP)
- Pattern searching using prefix array
- Find border of string
- Number of times a substring appears
- Smallest period of string
- Longest happy prefix
- String matching using Z-algorithm
- Repeated string match
- Shortest palindrome (prefix based)
- KMP pattern matching (Hard)

### 6Ô∏è‚É£ Pattern Matching Algorithms
**Core String Algorithms** ‚Ä¢ *15 Questions*

- [Easy] Naive pattern matching
- Rabin-Karp algorithm
- KMP algorithm
- Z-algorithm
- Find all pattern occurrences
- Longest prefix which is also suffix
- Count pattern occurrences
- String rotation check using matching
- Minimum characters to add to make palindrome
- Repeated substring pattern
- Longest substring repeating
- Periodic string check
- Pattern matching with wildcards
- Lexicographically smallest rotation
- Regex matching (Hard)

### 7Ô∏è‚É£ Palindrome-Focused Problems
**Very Common in Interviews** ‚Ä¢ *15 Questions*

- [Easy] Check palindrome string
- Longest palindromic substring
- Count palindromic substrings
- Palindromic partitioning
- Minimum cuts for palindrome partition
- Longest palindromic subsequence
- Palindrome pairs
- Break palindrome
- Shortest palindrome
- Valid palindrome II
- Remove palindromic subsequences
- Count different palindromic subsequences
- Maximum palindromes after operations
- Split string into max palindromes
- Palindrome partitioning II (Hard)

### 8Ô∏è‚É£ Substring vs Subsequence (DP on Strings)
**DP Mindset** ‚Ä¢ *15 Questions*

- [Easy] Check subsequence
- Longest common subsequence (LCS)
- Longest common substring
- Edit distance
- Shortest common supersequence
- Distinct subsequences
- Count distinct subsequences
- Minimum insertions to make palindrome
- Delete operation for two strings
- Interleaving string
- Wildcard matching
- Scramble string
- Longest repeating subsequence
- Regex matching
- Word break II (Hard)

### 9Ô∏è‚É£ Stack / Greedy on Strings
**Structure + Logic** ‚Ä¢ *15 Questions*

- [Easy] Valid parentheses
- Remove outer parentheses
- Remove adjacent duplicates
- Decode string
- Minimum remove to make valid parentheses
- Remove K digits
- Make string lexicographically smallest
- Remove duplicate letters
- Simplify path
- Reverse substrings between parentheses
- Check valid string with wildcards
- Score of parentheses
- Expression evaluation
- Remove invalid parentheses
- Decode ways II (Hard)

### üîü String Transformation / Conversion
**Practical Problems** ‚Ä¢ *15 Questions*

- [Easy] String to integer (atoi)
- Integer to Roman
- Roman to integer
- Zigzag conversion
- Reverse words in a string
- String compression
- URL encoding
- Reformat string
- License key formatting
- Encrypt string (run-length)
- Reorganize string
- Check if string can be rearranged
- Shift letters
- Minimum swaps to make strings equal
- Transform one string to another (Hard)

### 1Ô∏è‚É£1Ô∏è‚É£ Bit Manipulation / Special Strings
**Advanced & Tricky** ‚Ä¢ *15 Questions*

- [Easy] Check if all characters are unique
- XOR of strings
- Find odd-occurring character
- Binary string addition
- Count set bits in string
- Maximum XOR of two strings
- Binary substring problems
- Flip bits to make string alternate
- Count binary substrings
- Find missing binary string
- Longest binary substring with equal 0s & 1s
- Binary string reduction
- Split binary string into substrings
- Maximum score after splitting string
- Binary string transformation (Hard)

---

## üîç SEARCHING & SORTING

### 1Ô∏è‚É£ Linear Search
**Brute-Force Scanning Mindset** ‚Ä¢ *15 Questions*

- [Easy] Find an element in an array
- Find first occurrence of an element
- Find last occurrence of an element
- Count occurrences of a number
- Find missing number using linear scan
- Search in unsorted array with duplicates
- Find index of minimum element
- Find index of maximum element
- Find all pairs with given sum (brute)
- Find common elements in two arrays
- Check if array is sorted
- Find repeating elements
- Find first repeating element
- Find element occurring odd number of times
- Find majority element (brute force)

### 2Ô∏è‚É£ Binary Search (ALL VARIATIONS ‚Äì VERY IMPORTANT)
**Critical Pattern** ‚Ä¢ *15 Questions*

- [Easy] Binary search in sorted array
- First occurrence of target
- Last occurrence of target
- Count occurrences of target
- Search in nearly sorted array
- Find floor of a number
- Find ceil of a number
- Search in rotated sorted array
- Find minimum in rotated sorted array
- Peak element
- Find element in bitonic array
- Allocate minimum pages
- Aggressive cows
- Koko eating bananas
- Median of two sorted arrays (Hard)

### 3Ô∏è‚É£ Bubble Sort
**Understanding Swaps & Stability** ‚Ä¢ *15 Questions*

- [Easy] Implement Bubble Sort
- Optimized bubble sort (early stop)
- Count number of swaps
- Sort array of 0s, 1s, 2s (bubble idea)
- Check if array already sorted
- Find largest element after K passes
- Bubble sort on linked list
- Sort characters of string
- Sort array in descending order
- Find Kth largest using bubble
- Bubble sort with custom comparator
- Sort array by parity
- Bubble sort on 2D array
- Find minimum swaps to sort array
- Time complexity analysis of bubble sort (Hard)

### 4Ô∏è‚É£ Selection Sort
**Minimum Selection Logic** ‚Ä¢ *15 Questions*

- [Easy] Implement Selection Sort
- Sort array in descending order
- Find minimum swaps to sort array
- Sort array of strings
- Find Kth smallest element
- Stable vs unstable sort analysis
- Selection sort on linked list
- Selection sort for partially sorted array
- Sort array using minimum swaps
- Sort pairs based on first element
- Selection sort on 2D matrix
- Sort array by absolute difference
- Sort elements by frequency
- Selection sort for large inputs (analysis)
- Compare selection sort vs bubble sort (Hard)

### 5Ô∏è‚É£ Insertion Sort
**Shifting + Sorted Prefix** ‚Ä¢ *15 Questions*

- [Easy] Implement Insertion Sort
- Sort array using insertion sort (recursive)
- Sort linked list using insertion sort
- Insertion sort on nearly sorted array
- Find number of shifts required
- Sort strings using insertion sort
- Insertion sort with binary search
- Sort array of pairs
- Online sorting using insertion sort
- Sort stack using insertion sort
- Count inversions using insertion logic
- Insertion sort vs merge sort comparison
- Sorting large data streams
- Best case optimization
- Time complexity proof (Hard)

### 6Ô∏è‚É£ Merge Sort
**Divide & Conquer Powerhouse** ‚Ä¢ *15 Questions*

- [Easy] Implement Merge Sort
- Merge two sorted arrays
- Count inversions in array
- Merge sort on linked list
- Sort array of pairs
- Find median of sorted arrays
- Kth smallest element
- External sorting concept
- Sort array of strings
- Merge sort for large datasets
- Count smaller elements to right
- Reverse pairs problem
- Merge intervals
- Sort matrix rows
- Time & space optimization (Hard)

### 7Ô∏è‚É£ Quick Sort
**Partition-Based Logic** ‚Ä¢ *15 Questions*

- [Easy] Implement Quick Sort
- Lomuto partition
- Hoare partition
- Find Kth smallest element
- Quick select algorithm
- Sort array with duplicates
- Randomized quick sort
- Tail recursion optimization
- Quick sort on linked list
- Worst-case analysis
- Sort colors (Dutch National Flag)
- Partition array by pivot
- Sort intervals using quick sort
- In-place sorting analysis
- Hybrid quick sort (Hard)

### 8Ô∏è‚É£ Heap Sort
**Heap + Priority Queue Logic** ‚Ä¢ *15 Questions*

- [Easy] Implement Heap Sort
- Build max heap
- Build min heap
- Heapify an array
- Find Kth largest element
- Find Kth smallest element
- Merge K sorted arrays
- Sort nearly sorted array
- Top K frequent elements
- Heap sort on linked list
- Convert BST to min heap
- Find median in data stream
- Replace elements by rank
- Priority queue implementation
- Heap sort vs quick sort (Hard)

### 9Ô∏è‚É£ Counting Sort / Radix Sort
**Non-Comparison Sorting** ‚Ä¢ *15 Questions*

- [Easy] Implement Counting Sort
- Sort array with small range
- Sort characters of string
- Counting sort for negative numbers
- Stable counting sort
- Radix sort implementation
- Sort numbers by digit count
- Sort large integers efficiently
- Radix sort for strings
- Bucket sort basics
- Sort floating point numbers
- Frequency-based sorting
- Counting sort vs merge sort
- Space optimization in counting sort
- Time complexity analysis (Hard)

---

## üîó LINKED LISTS

### 1Ô∏è‚É£ Singly Linked List
**Foundation + Core Operations** ‚Ä¢ *15 Questions*

- [Easy] Insert a node at beginning
- Insert a node at end
- Insert at a given position
- Delete a node by value
- Delete a node by position
- Search an element
- Find length of linked list
- Find middle of linked list
- Reverse linked list (iterative)
- Reverse linked list (recursive)
- Find nth node from end
- Remove duplicates from sorted list
- Remove duplicates from unsorted list
- Merge two sorted linked lists
- Sort linked list (merge sort) (Hard)

### 2Ô∏è‚É£ Doubly Linked List
**Two-Direction Navigation** ‚Ä¢ *15 Questions*

- [Easy] Insert at front
- Insert at end
- Insert after a given node
- Delete from front
- Delete from end
- Delete a given node
- Traverse forward
- Traverse backward
- Reverse a doubly linked list
- Find middle element
- Convert DLL to circular DLL
- Rotate DLL by K nodes
- Remove duplicates from DLL
- Merge two DLLs
- Flatten multilevel DLL (Hard)

### 3Ô∏è‚É£ Circular Linked List
**No NULL Pointers** ‚Ä¢ *15 Questions*

- [Easy] Traverse circular linked list
- Insert at beginning
- Insert at end
- Delete head node
- Delete last node
- Search an element
- Split circular linked list into two halves
- Check if linked list is circular
- Count nodes in circular list
- Reverse circular linked list
- Convert circular to linear linked list
- Josephus problem
- Sorted insert in circular list
- Delete alternate nodes
- Clone circular linked list (Hard)

### 4Ô∏è‚É£ Fast & Slow Pointer
**Most Important Linked List Pattern** ‚Ä¢ *15 Questions*

- [Easy] Find middle of linked list
- Detect cycle in linked list
- Find length of cycle
- Find starting node of cycle
- Check if linked list is palindrome
- Remove cycle from linked list
- Happy number
- Find intersection point of two linked lists
- Find duplicate number (array)
- Reorder linked list
- Remove nth node from end
- Split linked list into halves
- Detect cycle in circular linked list
- Find loop in functional graph
- Floyd's algorithm proof (Hard)

### 5Ô∏è‚É£ Reverse Linked List
**In-Place Manipulation Mastery** ‚Ä¢ *15 Questions*

- [Easy] Reverse a linked list
- Reverse linked list recursively
- Reverse first K nodes
- Reverse linked list in groups of K
- Reverse alternate K nodes
- Reverse a sublist
- Reverse linked list using stack
- Reverse DLL
- Reverse circular linked list
- Reverse even-length groups
- Reverse linked list between positions
- Reverse nodes in pairs
- Reverse list and detect palindrome
- Reverse list without extra space
- Reverse nodes in increasing group size (Hard)

### 6Ô∏è‚É£ Cycle Detection
**Loop Logic Mastery** ‚Ä¢ *15 Questions*

- [Easy] Detect cycle in linked list
- Find starting point of cycle
- Find length of cycle
- Remove cycle from linked list
- Check if linked list is circular
- Detect cycle using hashing
- Find intersection point of two cyclic lists
- Find node where cycle begins
- Count number of nodes in loop
- Check cycle in doubly linked list
- Detect cycle in circular linked list
- Find loop in array representation
- Find duplicate in array using cycle detection
- Linked list with random pointer cycle
- Mathematical proof of cycle detection (Hard)

---

## üìö STACKS & QUEUES

### 1Ô∏è‚É£ Simple Queue
**FIFO Fundamentals** ‚Ä¢ *15 Questions*

- [Easy] Implement queue using array
- Implement queue using linked list
- Enqueue and dequeue operations
- Check overflow and underflow
- Implement queue using two stacks
- Implement stack using queue
- Reverse a queue
- Find first element after K operations
- Generate binary numbers from 1 to N
- Implement queue using recursion
- Find first non-repeating character in a stream
- Reverse first K elements of a queue
- Interleave first and second half of queue
- Sliding window maximum (queue based)
- Queue using one stack (Hard)

### 2Ô∏è‚É£ Circular Queue
**Efficient Space Utilization** ‚Ä¢ *15 Questions*

- [Easy] Implement circular queue
- Enqueue in circular queue
- Dequeue in circular queue
- Check full & empty conditions
- Circular queue using array
- Circular queue using linked list
- Design circular queue (LeetCode style)
- Resize circular queue dynamically
- Reverse circular queue
- Rotate circular queue by K
- Check if queue is circular
- Implement circular deque
- Circular tour / Petrol pump problem
- First negative integer in every window
- Josephus problem using circular queue (Hard)

### 3Ô∏è‚É£ Deque (Double-Ended Queue)
**Push & Pop from Both Ends** ‚Ä¢ *15 Questions*

- [Easy] Implement deque using array
- Implement deque using linked list
- Insert front in deque
- Insert rear in deque
- Delete front in deque
- Delete rear in deque
- Check palindrome using deque
- Sliding window maximum
- Find maximum of all subarrays of size K
- Circular deque implementation
- Reverse a deque
- Design deque data structure
- Minimum cost to add all elements
- Maximum sum subarray of size K
- Shortest subarray with sum ‚â• K (Hard)

### 4Ô∏è‚É£ Priority Queue
**Heap-Powered Queues** ‚Ä¢ *15 Questions*

- [Easy] Implement priority queue using heap
- Insert element in priority queue
- Delete highest priority element
- K largest elements
- K smallest elements
- Merge K sorted arrays
- Sort array using priority queue
- Median in a data stream
- Top K frequent elements
- Reorganize string
- Minimum cost to connect ropes
- Find K closest points to origin
- Task scheduler
- Sliding window median
- Dijkstra's algorithm (Hard)

### 5Ô∏è‚É£ Heap Implementation
**Core of Priority Queue** ‚Ä¢ *15 Questions*

- [Easy] Build a max heap
- Build a min heap
- Heapify an array
- Insert element in heap
- Delete root element
- Heap sort
- Convert min heap to max heap
- Find Kth largest element
- Find Kth smallest element
- Merge two heaps
- Check if array is a heap
- Replace elements by rank
- Implement priority queue from scratch
- Connect ropes with minimum cost
- Design heap with increase/decrease key (Hard)

---

## üîÑ RECURSION & BACKTRACKING

### 1Ô∏è‚É£ Recursion Basics
**Thinking Recursively, Not Coding Blindly** ‚Ä¢ *15 Questions*

- [Easy] Print numbers from 1 to N
- Print numbers from N to 1
- Calculate factorial of N
- Calculate power (a^b)
- Sum of digits
- Reverse a number
- Check palindrome (recursion)
- Count digits in a number
- Find GCD using recursion
- Fibonacci number
- Tower of Hanoi
- Print all binary strings of length N
- Count paths in a grid
- Josephus problem
- Recursive stack space analysis (Hard)

### 2Ô∏è‚É£ Subsets & Subsequences
**Pick / Not Pick Pattern** ‚Ä¢ *15 Questions*

- [Easy] Generate all subsets of a set
- Generate all subsequences of a string
- Count subsequences with sum = K
- Print subsequences with sum = K
- Subsets with duplicates
- Unique subsets
- Subsets using bit masking
- Subsequence with maximum sum
- Count subsequences divisible by K
- Palindromic subsequences
- Longest increasing subsequence (recursion)
- Partition array into equal sum subsets
- K-th lexicographic subset
- Subsets of size K
- Minimum deletions to make palindrome (Hard)

### 3Ô∏è‚É£ Permutations
**Fix One, Permute Rest** ‚Ä¢ *15 Questions*

- [Easy] Generate all permutations of a string
- Permutations of array
- Permutations with duplicates
- Unique permutations
- Permutations using swapping
- Permutations using frequency map
- Next permutation
- K-th permutation sequence
- Permutations of numbers 1 to N
- Permutations in lexicographic order
- Permutations of string with spaces
- Permutations with constraints
- String permutation substring check
- Permutation in string (sliding window)
- Permutation rank (Hard)

### 4Ô∏è‚É£ N-Queens
**Classic Backtracking Benchmark** ‚Ä¢ *15 Questions*

- [Easy] Solve N-Queens for N = 4
- Print all possible solutions
- Count total solutions
- Optimize using column hash
- Optimize using diagonal hash
- N-Queens using bit masking
- N-Queens with 1D board
- N-Queens time complexity analysis
- N-Queens space optimization
- N-Queens with blocked cells
- Place K queens on NxN board
- N-Queens with symmetry optimization
- N-Queens iterative solution
- N-Queens visualization
- Proof of correctness (Hard)

### 5Ô∏è‚É£ Sudoku Solver
**Backtracking + Constraints** ‚Ä¢ *15 Questions*

- [Easy] Solve a 9√ó9 Sudoku
- Validate Sudoku board
- Sudoku solver using backtracking
- Optimize using row/col/box hash
- Check if solution exists
- Count number of solutions
- Solve partially filled Sudoku
- Sudoku with custom size (NxN)
- Minimum clues Sudoku
- Sudoku generator
- Sudoku solver using bitmasking
- Solve diagonal Sudoku
- Time complexity analysis
- Space optimization
- Sudoku solver without recursion (Hard)

---

## üå≥ TREES

### 1Ô∏è‚É£ Binary Tree
**Structure + Recursion Mastery** ‚Ä¢ *15 Questions*

- [Easy] Create a binary tree & print nodes
- Count total nodes in binary tree
- Count leaf nodes
- Count non-leaf nodes
- Sum of all nodes
- Check if two trees are identical
- Check if tree is symmetric
- Mirror a binary tree
- Convert binary tree to doubly linked list
- Flatten binary tree to linked list
- Check if binary tree is height balanced
- Check if binary tree is a sum tree
- Check if binary tree is a complete tree
- Serialize and deserialize binary tree
- Construct tree from inorder & preorder (Hard)

### 2Ô∏è‚É£ Tree Traversals (DFS)
**Recursive + Iterative** ‚Ä¢ *15 Questions*

- [Easy] Inorder traversal (recursive)
- Inorder traversal (iterative)
- Preorder traversal (recursive)
- Preorder traversal (iterative)
- Postorder traversal (recursive)
- Postorder traversal (iterative ‚Äì 2 stacks)
- Postorder traversal (iterative ‚Äì 1 stack)
- Morris inorder traversal
- Morris preorder traversal
- Boundary traversal
- Diagonal traversal
- Zigzag traversal (DFS approach)
- Vertical traversal (DFS based)
- All traversals in one recursion
- Threaded binary tree traversal (Hard)

### 3Ô∏è‚É£ Level Order Traversal (BFS)
**Queue-Based Thinking** ‚Ä¢ *15 Questions*

- [Easy] Level order traversal
- Reverse level order traversal
- Level order traversal line by line
- Zigzag (spiral) level order traversal
- Vertical order traversal
- Bottom view of binary tree
- Top view of binary tree
- Left view of binary tree
- Right view of binary tree
- Average of levels in binary tree
- Maximum width of binary tree
- Print nodes at distance K
- Burning tree problem
- Minimum time to burn binary tree
- Binary tree cameras (Hard)

### 4Ô∏è‚É£ Height & Diameter
**Postorder Logic** ‚Ä¢ *15 Questions*

- [Easy] Find height of binary tree
- Diameter of binary tree (O(n¬≤))
- Diameter of binary tree (O(n))
- Check if tree is balanced
- Maximum depth of binary tree
- Minimum depth of binary tree
- Longest path between two leaves
- Maximum path sum
- Sum of longest root-to-leaf path
- Height of tree using level order
- Height of skewed tree
- Count nodes in complete binary tree
- Find deepest node
- Height after deleting a node
- Diameter with path printing (Hard)

### 5Ô∏è‚É£ Lowest Common Ancestor (LCA)
**Ancestor Logic = Interview Favorite** ‚Ä¢ *15 Questions*

- [Easy] LCA in binary tree
- LCA using recursion
- LCA using parent pointers
- LCA in Binary Search Tree
- Distance between two nodes
- Kth ancestor of a node
- Print path from root to node
- Find ancestors of a node
- Check if one node is ancestor of another
- Lowest common ancestor with constraints
- LCA of deepest leaves
- Binary lifting (intro)
- LCA with multiple queries
- LCA in N-ary tree
- LCA using Euler tour + RMQ (Hard)

---

## üóÇÔ∏è HEAPS

### 1Ô∏è‚É£ Min Heap / Max Heap
**Core Heap Operations & Understanding** ‚Ä¢ *15 Questions*

- [Easy] Implement Min Heap
- Implement Max Heap
- Insert element into Min Heap
- Insert element into Max Heap
- Delete root from Min Heap
- Delete root from Max Heap
- Increase key in Max Heap
- Decrease key in Min Heap
- Convert Min Heap to Max Heap
- Convert Max Heap to Min Heap
- Check if array represents a heap
- Merge two heaps
- Build heap from unsorted array
- Implement priority queue using heap
- Design heap from scratch (Hard)

### 2Ô∏è‚É£ Heapify
**Bottom-Up Optimization** ‚Ä¢ *15 Questions*

- [Easy] Heapify an array
- Heapify subtree rooted at index i
- Build heap using heapify
- Heapify in O(n) proof
- Heap sort using heapify
- Heapify for Min Heap
- Heapify for Max Heap
- Convert array to heap
- Fix heap after insertion
- Fix heap after deletion
- Heapify for nearly sorted array
- Heapify for K-sorted array
- Heapify for dynamic input
- Heapify iterative vs recursive
- Space-optimized heapify (Hard)

### 3Ô∏è‚É£ Top-K Problems
**Most Asked Heap Pattern** ‚Ä¢ *15 Questions*

- [Easy] Find K largest elements
- Find K smallest elements
- Top K frequent elements
- Kth largest element
- Kth smallest element
- Sort array by frequency
- K closest points to origin
- K closest numbers to X
- Top K largest sums
- K most frequent words
- K smallest pairs
- Find K strongest values
- Top K students by marks
- K largest subarray sums
- Top K elements from stream (Hard)

### 4Ô∏è‚É£ Median in a Stream
**Two-Heap Technique** ‚Ä¢ *15 Questions*

- [Easy] Find median of running stream
- Median in data stream (two heaps)
- Median after each insertion
- Sliding window median
- Median of even number of elements
- Median of odd number of elements
- Maintain median dynamically
- Remove element and update median
- Median in infinite stream
- Median with duplicates
- Median of two sorted arrays (heap approach)
- Median in large data sets
- Median in distributed systems
- Median using balanced BST vs heap
- Proof of correctness (Hard)

---

## üï∏Ô∏è GRAPHS

### 1Ô∏è‚É£ Graph Representation
**Foundation ‚Äî MUST Be Strong** ‚Ä¢ *15 Questions*

- [Easy] Represent graph using adjacency list
- Represent graph using adjacency matrix
- Convert edge list to adjacency list
- Undirected graph representation
- Directed graph representation
- Weighted graph representation
- Graph with self-loops
- Graph with parallel edges
- Memory comparison: list vs matrix
- Graph input handling for CP
- Dynamic graph representation
- Represent graph for BFS/DFS
- Represent graph for shortest path
- Represent graph using map/set
- Space-time complexity analysis (Hard)

### 2Ô∏è‚É£ BFS & DFS
**Traversal = Backbone of Graph Problems** ‚Ä¢ *15 Questions*

- [Easy] BFS traversal
- DFS traversal (recursive)
- DFS traversal (iterative)
- BFS in disconnected graph
- DFS in disconnected graph
- Level order traversal of graph
- BFS using adjacency matrix
- DFS using adjacency list
- BFS vs DFS comparison
- Count nodes at each level
- Find depth of graph
- Detect cycle using DFS
- Path existence using DFS
- Shortest path in unweighted graph
- BFS/DFS complexity proof (Hard)

### 3Ô∏è‚É£ Connected Components
**Disjoint Pieces Logic** ‚Ä¢ *15 Questions*

- [Easy] Count connected components
- Print all connected components
- Connected components in directed graph
- Strongly connected components (Kosaraju)
- Strongly connected components (Tarjan)
- Count SCCs
- Largest connected component
- Smallest connected component
- Connected components using DFS
- Connected components using BFS
- Connected components in grid
- Number of islands
- Dynamic connectivity
- Find articulation points
- Find bridges (Hard)

### 4Ô∏è‚É£ Cycle Detection
**Directed vs Undirected = Very Important** ‚Ä¢ *15 Questions*

- [Easy] Detect cycle in undirected graph (DFS)
- Detect cycle in undirected graph (BFS)
- Detect cycle using Union-Find
- Detect cycle in directed graph (DFS)
- Detect cycle using recursion stack
- Detect cycle in directed graph (Kahn's Algo)
- Detect cycle in weighted graph
- Cycle detection in graph with self-loops
- Cycle detection in disconnected graph
- Length of shortest cycle
- Find all cycles in graph
- Detect cycle in grid
- Detect negative weight cycle
- Course schedule problem
- Mathematical proof of cycle detection (Hard)

### 5Ô∏è‚É£ Topological Sort
**Only for DAGs** ‚Ä¢ *15 Questions*

- [Easy] Topological sort using DFS
- Topological sort using BFS (Kahn's)
- Detect cycle using topo sort
- Topological sort in disconnected DAG
- Lexicographically smallest topo order
- All possible topological sorts
- Course schedule
- Course schedule II
- Topological sort for job scheduling
- Alien dictionary
- Topological sort with weighted edges
- Longest path in DAG
- Shortest path in DAG
- DAG validation
- Proof of correctness (Hard)

### 6Ô∏è‚É£ Shortest Path (General)
**Choose Algorithm Wisely** ‚Ä¢ *15 Questions*

- [Easy] Shortest path in unweighted graph
- Shortest path using BFS
- Shortest path in DAG
- Shortest path with negative edges
- Shortest path with cycles
- Multi-source shortest path
- Shortest path in grid
- Shortest path with obstacles
- Shortest path in weighted graph
- Shortest path using priority queue
- Shortest path with constraints
- Shortest path in directed graph
- Shortest path with k edges
- Shortest path in time-dependent graph
- Shortest path complexity analysis (Hard)

### 7Ô∏è‚É£ Dijkstra Algorithm
**Greedy + Heap** ‚Ä¢ *15 Questions*

- [Easy] Dijkstra implementation
- Dijkstra using priority queue
- Dijkstra using set
- Dijkstra on adjacency matrix
- Dijkstra on adjacency list
- Dijkstra in directed graph
- Dijkstra in undirected graph
- Dijkstra with path reconstruction
- Dijkstra on grid
- Dijkstra with multiple sources
- Dijkstra with constraints
- Network delay time
- Shortest path in weighted DAG
- Why Dijkstra fails for negative edges
- Proof of correctness (Hard)

### 8Ô∏è‚É£ Bellman‚ÄìFord
**Handles Negative Edges** ‚Ä¢ *15 Questions*

- [Easy] Bellman-Ford implementation
- Detect negative weight cycle
- Shortest path with negative edges
- Bellman-Ford vs Dijkstra
- Bellman-Ford on directed graph
- Bellman-Ford on undirected graph
- Bellman-Ford for currency exchange
- Relaxation process explanation
- Early stopping optimization
- Bellman-Ford on disconnected graph
- Find shortest path tree
- Bellman-Ford time complexity
- Difference constraints problem
- Flight routes with at most K stops
- Proof of correctness (Hard)

### 9Ô∏è‚É£ Floyd‚ÄìWarshall
**All-Pairs Shortest Path** ‚Ä¢ *15 Questions*

- [Easy] Floyd-Warshall implementation
- All-pairs shortest path
- Floyd-Warshall with path reconstruction
- Detect negative cycles
- Transitive closure of graph
- Floyd-Warshall vs Dijkstra
- Floyd-Warshall on weighted graph
- Floyd-Warshall on directed graph
- Floyd-Warshall on undirected graph
- APSP in dense graphs
- Shortest paths in matrix
- Minimum cost conversion problems
- Graph reachability
- Floyd-Warshall optimization
- Proof of correctness (Hard)

### üîü Minimum Spanning Tree (MST)
**Greedy Graph Problems** ‚Ä¢ *15 Questions*

- [Easy] What is Minimum Spanning Tree
- Find MST using Prim
- Find MST using Kruskal
- MST in weighted graph
- MST in dense graph
- MST in sparse graph
- MST uniqueness
- Total weight of MST
- Count number of MSTs
- MST for disconnected graph
- MST using adjacency matrix
- MST using adjacency list
- Applications of MST
- Minimum cost to connect all nodes
- Proof of MST properties (Hard)

### 1Ô∏è‚É£1Ô∏è‚É£ Prim's Algorithm
**Greedy + Heap** ‚Ä¢ *15 Questions*

- [Easy] Prim's algorithm implementation
- Prim using priority queue
- Prim using adjacency matrix
- Prim using adjacency list
- Prim vs Kruskal
- Prim for dense graph
- Prim for sparse graph
- Prim with path tracking
- Prim for directed graph (why not)
- Minimum cost to connect cities
- Network connection problem
- Prim time complexity
- Space optimization
- Handling disconnected graphs
- Proof of correctness (Hard)

### 1Ô∏è‚É£2Ô∏è‚É£ Kruskal's Algorithm
**Sorting + Union-Find** ‚Ä¢ *15 Questions*

- [Easy] Kruskal's algorithm implementation
- Sort edges by weight
- Union-Find implementation
- Path compression
- Union by rank
- Cycle detection using DSU
- Kruskal vs Prim
- MST using Kruskal
- Kruskal on disconnected graph
- Kruskal for sparse graph
- Kruskal time complexity
- Build MST from edge list
- Minimum cost to connect components
- Kruskal with large constraints
- Proof of correctness (Hard)

---

## üí° GREEDY ALGORITHMS

### 1Ô∏è‚É£ Activity Selection
**Choose Optimally at Each Step** ‚Ä¢ *15 Questions*

- [Easy] Activity Selection Problem
- Activity selection using end time sorting
- Activity selection using start time sorting
- Activity selection with multiple rooms
- Maximum number of meetings in one room
- Select maximum non-overlapping intervals
- Activity selection with deadlines
- Activity selection with profit
- Weighted activity selection
- Activity selection in circular timeline
- Activity selection with fixed breaks
- Activity selection in distributed systems
- Online activity selection
- Greedy vs DP comparison
- Proof of correctness (Hard)

### 2Ô∏è‚É£ Job Sequencing
**Deadlines + Profit** ‚Ä¢ *15 Questions*

- [Easy] Job sequencing with deadlines
- Job sequencing using greedy approach
- Job sequencing using priority queue
- Maximize profit with deadlines
- Job sequencing with varying deadlines
- Job sequencing with losses
- Job sequencing with negative profit
- Job sequencing on multiple machines
- Job sequencing with dependency
- Job sequencing with weighted profit
- Job sequencing with release times
- Online job sequencing
- Job sequencing optimization
- Time complexity analysis
- Proof of correctness (Hard)

### 3Ô∏è‚É£ Huffman Coding
**Greedy + Heap** ‚Ä¢ *15 Questions*

- [Easy] Build Huffman Tree
- Huffman encoding
- Huffman decoding
- Huffman coding using priority queue
- Generate Huffman codes
- Calculate compression ratio
- Huffman coding with equal frequencies
- Huffman coding for large alphabets
- Huffman coding for strings
- Optimal merge pattern
- Huffman coding vs fixed length encoding
- Huffman coding time complexity
- Canonical Huffman codes
- Huffman coding in file compression
- Proof of optimality (Hard)

### 4Ô∏è‚É£ Fractional Knapsack
**Greedy by Ratio** ‚Ä¢ *15 Questions*

- [Easy] Fractional Knapsack problem
- Sort items by value/weight ratio
- Fractional knapsack using greedy
- Fractional knapsack with floating weights
- Fractional knapsack with large constraints
- Fractional knapsack vs 0/1 knapsack
- Fractional knapsack with identical items
- Fractional knapsack with precision issues
- Knapsack with time constraints
- Knapsack with multiple capacities
- Online fractional knapsack
- Fractional knapsack using heap
- Fractional knapsack in logistics
- Fractional knapsack optimization
- Proof of correctness (Hard)

---

## üìä Summary Statistics

| Topic | Patterns | Total Questions |
|-------|----------|-----------------|
| Arrays | 11 | 165 |
| Strings | 11 | 165 |
| Searching & Sorting | 9 | 135 |
| Linked Lists | 6 | 90 |
| Stacks & Queues | 5 | 75 |
| Recursion & Backtracking | 5 | 75 |
| Trees | 5 | 75 |
| Heaps | 4 | 60 |
| Graphs | 12 | 180 |
| Greedy | 4 | 60 |
| **TOTAL** | **72** | **1,080** |

---

## üéØ How to Use This Guide

1. **Start with Basics**: Begin with [Easy] marked questions in each pattern
2. **Pattern Mastery**: Complete all questions in a pattern before moving to the next
3. **Progressive Difficulty**: Move from Easy ‚Üí Medium ‚Üí Hard within each pattern
4. **Focus on High Priority**: Patterns marked as "Very High Priority" or "Must-Master"
5. **Practice Regularly**: Solve at least 2-3 problems daily
6. **Review & Revise**: Revisit solved problems after 1 week, 1 month

---

## üèÜ Recommended Learning Path

### Phase 1: Foundations (2-3 months)
- Arrays: Basic Traversal, Two Pointers, Sliding Window
- Strings: Basic Traversal, Two Pointers, Hashing
- Searching: Linear Search, Binary Search
- Sorting: Bubble, Selection, Insertion, Merge Sort

### Phase 2: Intermediate (2-3 months)
- Arrays: Prefix Sum, Hashing, Binary Search
- Strings: Sliding Window, Palindromes, Pattern Matching
- Linked Lists: All patterns
- Stacks & Queues: All patterns
- Recursion: Basics, Subsets, Permutations

### Phase 3: Advanced (3-4 months)
- Trees: All patterns
- Heaps: All patterns
- Graphs: BFS/DFS, Shortest Path algorithms
- DP on Arrays & Strings
- Advanced Recursion & Backtracking

### Phase 4: Mastery (2-3 months)
- Graph Advanced: MST, Advanced shortest paths
- Greedy Algorithms
- Hard problems across all topics
- Mock interviews & timed practice

---

## üíª Contributing

Feel free to contribute by:
- Adding more problems
- Improving problem descriptions
- Adding solution links
- Reporting errors

---

## üìù License

This is a free educational resource. Share and learn! üöÄ

---

## üîó Additional Resources

- [LeetCode](https://leetcode.com)
- [GeeksforGeeks](https://www.geeksforgeeks.org)
- [HackerRank](https://www.hackerrank.com)
- [Codeforces](https://codeforces.com)
- [InterviewBit](https://www.interviewbit.com)

---

**Happy Coding! üí™**

*Last Updated: January 2026*
